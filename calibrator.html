<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Calibrator - Geography Puzzle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        h1 { text-align: center; margin-bottom: 20px; color: #4ecdc4; }
        .container { max-width: 1500px; margin: 0 auto; display: flex; gap: 20px; flex-wrap: wrap; }
        .map-section { flex: 1; min-width: 600px; }
        .controls-section { width: 380px; background: #16213e; border-radius: 10px; padding: 20px; max-height: 90vh; overflow-y: auto; }
        .map-container { position: relative; background: #0f3460; border-radius: 10px; overflow: hidden; cursor: crosshair; }
        #mapImage { width: 100%; display: block; }
        #svgOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .coords-display {
            position: absolute; bottom: 10px; left: 10px;
            background: rgba(0,0,0,0.8); padding: 10px 15px; border-radius: 5px;
            font-family: monospace; font-size: 14px; direction: ltr;
        }
        .mode-selector { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; }
        .mode-btn {
            flex: 1; min-width: 80px; padding: 10px 6px; border: none; border-radius: 5px;
            cursor: pointer; background: #0f3460; color: #fff; font-size: 13px; transition: all 0.2s;
        }
        .mode-btn.active { background: #4ecdc4; color: #1a1a2e; }
        .mode-btn:hover { opacity: 0.8; }
        .output-section { margin-top: 20px; }
        .output-section h3 { margin-bottom: 10px; color: #4ecdc4; }
        #output {
            width: 100%; height: 250px; background: #0a0a14; border: 1px solid #333;
            border-radius: 5px; color: #4ecdc4; padding: 10px; font-family: monospace;
            font-size: 11px; resize: vertical; direction: ltr;
        }
        .btn {
            padding: 10px 16px; border: none; border-radius: 5px; cursor: pointer;
            font-size: 13px; margin: 5px; transition: all 0.2s;
        }
        .btn-primary { background: #4ecdc4; color: #1a1a2e; }
        .btn-secondary { background: #e94560; color: #fff; }
        .btn-warning { background: #f39c12; color: #1a1a2e; }
        .btn:hover { opacity: 0.8; }
        .item-list { max-height: 250px; overflow-y: auto; margin-top: 10px; }
        .item {
            background: #0f3460; padding: 8px 10px; margin: 4px 0; border-radius: 5px;
            cursor: pointer; transition: all 0.2s; font-size: 13px;
        }
        .item:hover { background: #1a4a7a; }
        .item.selected { border: 2px solid #4ecdc4; }
        .item-name { font-weight: bold; }
        .item-coords { font-size: 10px; color: #888; font-family: monospace; direction: ltr; margin-top: 3px; }
        .instructions { background: #0f3460; padding: 12px; border-radius: 5px; margin-bottom: 15px; font-size: 12px; line-height: 1.5; }
        .instructions h4 { color: #4ecdc4; margin-bottom: 8px; }
        .input-group { margin: 10px 0; }
        .input-group label { display: block; margin-bottom: 5px; color: #888; font-size: 13px; }
        .input-group input {
            width: 100%; padding: 8px; border: 1px solid #333; border-radius: 5px;
            background: #0a0a14; color: #fff; font-size: 14px;
        }
        .tab-buttons { display: flex; gap: 5px; margin-bottom: 10px; }
        .tab-btn {
            flex: 1; padding: 8px; border: none; border-radius: 5px 5px 0 0;
            cursor: pointer; background: #0f3460; color: #888; font-size: 12px;
        }
        .tab-btn.active { background: #16213e; color: #4ecdc4; border-bottom: 2px solid #4ecdc4; }
        .point-count { background: #0f3460; padding: 8px 12px; border-radius: 5px; margin: 10px 0; font-size: 13px; color: #4ecdc4; }
        .undo-hint { font-size: 11px; color: #888; margin-top: 5px; }
    </style>
</head>
<body>
    <h1>Map Calibrator Tool</h1>

    <div class="container">
        <div class="map-section">
            <div class="map-container" id="mapContainer">
                <img id="mapImage" src="world_map.png" alt="World Map">
                <svg id="svgOverlay" viewBox="0 0 1 1" preserveAspectRatio="none"></svg>
                <div class="coords-display" id="coordsDisplay">X: 0.000 | Y: 0.000</div>
            </div>
        </div>

        <div class="controls-section">
            <div class="instructions">
                <h4>How to Use</h4>
                <p><strong>Point Mode:</strong> Click to mark a city location</p>
                <p><strong>Polygon Mode:</strong> Click to add polygon vertices. Double-click or press Enter to finish.</p>
                <p><strong>Rectangle Mode:</strong> Click and drag to mark bounds</p>
                <p>Coordinates are normalized 0-1</p>
            </div>

            <div class="mode-selector">
                <button class="mode-btn active" data-mode="point" onclick="setMode('point')">Point</button>
                <button class="mode-btn" data-mode="polygon" onclick="setMode('polygon')">Polygon</button>
                <button class="mode-btn" data-mode="rect" onclick="setMode('rect')">Rectangle</button>
            </div>

            <div class="input-group">
                <label>Item Name</label>
                <input type="text" id="itemName" placeholder="e.g. ברזיל">
            </div>

            <div id="polygonInfo" class="point-count" style="display:none;">
                Points: <span id="pointCount">0</span>
                <div class="undo-hint">Right-click to undo last point. Double-click or Enter to finish.</div>
            </div>

            <div class="tab-buttons">
                <button class="tab-btn active" onclick="showTab('continents')">Continents</button>
                <button class="tab-btn" onclick="showTab('countries')">Countries</button>
                <button class="tab-btn" onclick="showTab('cities')">Cities</button>
            </div>

            <div class="item-list" id="itemList"></div>

            <div style="margin-top: 15px;">
                <button class="btn btn-warning" onclick="loadExistingData()">Load Game Data</button>
            </div>

            <div class="output-section">
                <h3>Generated Code</h3>
                <textarea id="output" readonly></textarea>
                <button class="btn btn-primary" onclick="copyOutput()">Copy</button>
                <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
                <button class="btn btn-primary" onclick="exportAll()">Export JSON</button>
            </div>
        </div>
    </div>

    <script>
        let mode = 'point';
        let isDrawing = false;
        let startX = 0, startY = 0;
        let currentTab = 'continents';
        let currentPolygonPoints = [];

        const calibrations = { continents: [], countries: [], cities: [] };

        const svgOverlay = document.getElementById('svgOverlay');
        const mapImage = document.getElementById('mapImage');
        const coordsDisplay = document.getElementById('coordsDisplay');
        const output = document.getElementById('output');
        const svgNS = 'http://www.w3.org/2000/svg';

        function getNormalizedCoords(e) {
            const rect = mapImage.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
        }

        // Mouse move
        document.getElementById('mapContainer').addEventListener('mousemove', (e) => {
            const coords = getNormalizedCoords(e);
            const px = Math.round(coords.x * 1408);
            const py = Math.round(coords.y * 768);
            coordsDisplay.textContent = `X: ${coords.x.toFixed(3)} | Y: ${coords.y.toFixed(3)} | px: ${px}, ${py}`;

            if (isDrawing && mode === 'rect') {
                updateRectPreview(coords);
            }
            if (mode === 'polygon' && currentPolygonPoints.length > 0) {
                updatePolygonPreview(coords);
            }
        });

        // Mouse down
        document.getElementById('mapContainer').addEventListener('mousedown', (e) => {
            if (e.button === 2) return; // right click handled separately
            const coords = getNormalizedCoords(e);

            if (mode === 'point') {
                addPointMarker(coords);
            } else if (mode === 'polygon') {
                addPolygonPoint(coords);
            } else if (mode === 'rect') {
                startX = coords.x;
                startY = coords.y;
                isDrawing = true;
            }
        });

        // Mouse up
        document.getElementById('mapContainer').addEventListener('mouseup', (e) => {
            if (isDrawing && mode === 'rect') {
                finishRect(getNormalizedCoords(e));
            }
            isDrawing = false;
        });

        // Double click to finish polygon
        document.getElementById('mapContainer').addEventListener('dblclick', (e) => {
            if (mode === 'polygon' && currentPolygonPoints.length >= 3) {
                e.preventDefault();
                finishPolygon();
            }
        });

        // Right click to undo polygon point
        document.getElementById('mapContainer').addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (mode === 'polygon' && currentPolygonPoints.length > 0) {
                currentPolygonPoints.pop();
                document.getElementById('pointCount').textContent = currentPolygonPoints.length;
                renderOverlay();
            }
        });

        // Enter to finish polygon
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && mode === 'polygon' && currentPolygonPoints.length >= 3) {
                finishPolygon();
            }
            if (e.key === 'Escape' && mode === 'polygon') {
                currentPolygonPoints = [];
                document.getElementById('pointCount').textContent = '0';
                renderOverlay();
            }
        });

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === newMode);
            });
            document.getElementById('polygonInfo').style.display = newMode === 'polygon' ? 'block' : 'none';
            if (newMode !== 'polygon') {
                currentPolygonPoints = [];
                document.getElementById('pointCount').textContent = '0';
            }
        }

        function addPointMarker(coords) {
            const name = document.getElementById('itemName').value || 'Unnamed';
            calibrations[currentTab].push({ name, position: { x: coords.x, y: coords.y } });
            updateItemList();
            updateOutput();
            renderOverlay();
        }

        function addPolygonPoint(coords) {
            currentPolygonPoints.push([parseFloat(coords.x.toFixed(3)), parseFloat(coords.y.toFixed(3))]);
            document.getElementById('pointCount').textContent = currentPolygonPoints.length;
            renderOverlay();
        }

        function finishPolygon() {
            const name = document.getElementById('itemName').value || 'Unnamed';
            const outline = [...currentPolygonPoints];

            // Calculate bounding box
            let minX = 1, minY = 1, maxX = 0, maxY = 0;
            outline.forEach(([x, y]) => {
                minX = Math.min(minX, x); minY = Math.min(minY, y);
                maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
            });

            calibrations[currentTab].push({
                name,
                bounds: { x: minX, y: minY, width: maxX - minX, height: maxY - minY },
                outline
            });

            currentPolygonPoints = [];
            document.getElementById('pointCount').textContent = '0';
            updateItemList();
            updateOutput();
            renderOverlay();
        }

        let rectPreview = null;
        function updateRectPreview(coords) {
            if (!rectPreview) {
                rectPreview = document.createElementNS(svgNS, 'rect');
                rectPreview.setAttribute('fill', 'rgba(78, 205, 196, 0.3)');
                rectPreview.setAttribute('stroke', '#4ecdc4');
                rectPreview.setAttribute('stroke-width', '0.002');
                svgOverlay.appendChild(rectPreview);
            }
            const x = Math.min(startX, coords.x);
            const y = Math.min(startY, coords.y);
            const w = Math.abs(coords.x - startX);
            const h = Math.abs(coords.y - startY);
            rectPreview.setAttribute('x', x);
            rectPreview.setAttribute('y', y);
            rectPreview.setAttribute('width', w);
            rectPreview.setAttribute('height', h);
        }

        function updatePolygonPreview(coords) {
            renderOverlay();
            // Draw line from last point to cursor
            if (currentPolygonPoints.length > 0) {
                const last = currentPolygonPoints[currentPolygonPoints.length - 1];
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', last[0]);
                line.setAttribute('y1', last[1]);
                line.setAttribute('x2', coords.x);
                line.setAttribute('y2', coords.y);
                line.setAttribute('stroke', 'rgba(255,255,0,0.6)');
                line.setAttribute('stroke-width', '0.002');
                line.setAttribute('stroke-dasharray', '0.005,0.005');
                svgOverlay.appendChild(line);
            }
        }

        function finishRect(endCoords) {
            const name = document.getElementById('itemName').value || 'Unnamed';
            const x = Math.min(startX, endCoords.x);
            const y = Math.min(startY, endCoords.y);
            const width = Math.abs(endCoords.x - startX);
            const height = Math.abs(endCoords.y - startY);

            if (width < 0.01 || height < 0.01) { rectPreview?.remove(); rectPreview = null; return; }

            calibrations[currentTab].push({ name, bounds: { x, y, width, height } });
            rectPreview = null;
            updateItemList();
            updateOutput();
            renderOverlay();
        }

        function showTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(
                    tab === 'continents' ? 'continent' : tab === 'countries' ? 'countr' : 'cit'
                ));
            });
            updateItemList();
            renderOverlay();
        }

        function renderOverlay() {
            svgOverlay.innerHTML = '';
            const colors = { continents: '#4ecdc4', countries: '#ff6b6b', cities: '#ffd93d' };
            const color = colors[currentTab] || '#4ecdc4';

            calibrations[currentTab].forEach((item, idx) => {
                if (item.outline) {
                    const polygon = document.createElementNS(svgNS, 'polygon');
                    polygon.setAttribute('points', item.outline.map(([x,y]) => `${x},${y}`).join(' '));
                    polygon.setAttribute('fill', color.replace(')', ',0.25)').replace('rgb', 'rgba').replace('#', ''));
                    polygon.setAttribute('fill', `${color}40`);
                    polygon.setAttribute('stroke', color);
                    polygon.setAttribute('stroke-width', '0.002');
                    polygon.style.cursor = 'pointer';
                    polygon.onclick = () => highlightItem(idx);
                    svgOverlay.appendChild(polygon);
                } else if (item.bounds) {
                    const rect = document.createElementNS(svgNS, 'rect');
                    rect.setAttribute('x', item.bounds.x);
                    rect.setAttribute('y', item.bounds.y);
                    rect.setAttribute('width', item.bounds.width);
                    rect.setAttribute('height', item.bounds.height);
                    rect.setAttribute('fill', `${color}40`);
                    rect.setAttribute('stroke', color);
                    rect.setAttribute('stroke-width', '0.002');
                    svgOverlay.appendChild(rect);
                } else if (item.position) {
                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('cx', item.position.x);
                    circle.setAttribute('cy', item.position.y);
                    circle.setAttribute('r', '0.008');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '0.002');
                    svgOverlay.appendChild(circle);

                    // Label
                    const text = document.createElementNS(svgNS, 'text');
                    text.setAttribute('x', item.position.x + 0.012);
                    text.setAttribute('y', item.position.y + 0.004);
                    text.setAttribute('fill', '#fff');
                    text.setAttribute('font-size', '0.012');
                    text.setAttribute('font-family', 'sans-serif');
                    text.textContent = item.name;
                    svgOverlay.appendChild(text);
                }
            });

            // Draw current polygon being traced
            if (currentPolygonPoints.length > 0) {
                // Draw completed segments
                if (currentPolygonPoints.length >= 2) {
                    const polyline = document.createElementNS(svgNS, 'polyline');
                    polyline.setAttribute('points', currentPolygonPoints.map(([x,y]) => `${x},${y}`).join(' '));
                    polyline.setAttribute('fill', 'none');
                    polyline.setAttribute('stroke', '#ffff00');
                    polyline.setAttribute('stroke-width', '0.002');
                    svgOverlay.appendChild(polyline);
                }

                // Draw vertices
                currentPolygonPoints.forEach(([x, y], i) => {
                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', i === 0 ? '0.006' : '0.004');
                    circle.setAttribute('fill', i === 0 ? '#00ff00' : '#ffff00');
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '0.001');
                    svgOverlay.appendChild(circle);
                });
            }
        }

        function highlightItem(idx) {
            const item = calibrations[currentTab][idx];
            if (confirm(`Delete "${item.name}"?`)) {
                calibrations[currentTab].splice(idx, 1);
                updateItemList();
                updateOutput();
                renderOverlay();
            }
        }

        function updateItemList() {
            const list = document.getElementById('itemList');
            list.innerHTML = '';

            calibrations[currentTab].forEach((item, idx) => {
                const div = document.createElement('div');
                div.className = 'item';
                const type = item.outline ? 'polygon' : (item.position ? 'point' : 'rect');
                const coordsText = item.outline
                    ? `polygon: ${item.outline.length} points`
                    : item.position
                        ? `position: (${item.position.x.toFixed(3)}, ${item.position.y.toFixed(3)})`
                        : `bounds: (${item.bounds.x.toFixed(3)}, ${item.bounds.y.toFixed(3)}, ${item.bounds.width.toFixed(3)}, ${item.bounds.height.toFixed(3)})`;
                div.innerHTML = `<div class="item-name">${item.name} [${type}]</div><div class="item-coords">${coordsText}</div>`;
                div.onclick = () => {
                    // Flash the item
                    renderOverlay();
                };
                list.appendChild(div);
            });
        }

        function updateOutput() {
            let code = '';
            for (const [tab, items] of Object.entries(calibrations)) {
                if (items.length === 0) continue;
                code += `// ${tab}\n`;
                items.forEach(item => {
                    if (item.outline) {
                        code += `{ name: '${item.name}', outline: [\n`;
                        item.outline.forEach(([x, y], i) => {
                            code += `    [${x.toFixed(3)}, ${y.toFixed(3)}]${i < item.outline.length - 1 ? ',' : ''}\n`;
                        });
                        code += `]},\n`;
                    } else if (item.position) {
                        code += `{ name: '${item.name}', position: { x: ${item.position.x.toFixed(3)}, y: ${item.position.y.toFixed(3)} } },\n`;
                    } else if (item.bounds) {
                        code += `{ name: '${item.name}', bounds: { x: ${item.bounds.x.toFixed(3)}, y: ${item.bounds.y.toFixed(3)}, width: ${item.bounds.width.toFixed(3)}, height: ${item.bounds.height.toFixed(3)} } },\n`;
                    }
                });
                code += '\n';
            }
            output.value = code;
        }

        function loadExistingData() {
            // Load from the game's GeoData - fetch game.js and parse
            fetch('game.js')
                .then(r => r.text())
                .then(text => {
                    // Simple extraction - find GeoData object
                    const match = text.match(/const GeoData = ({[\s\S]*?});/);
                    if (match) {
                        try {
                            const data = eval('(' + match[1] + ')');
                            if (data.continents) {
                                calibrations.continents = data.continents.map(c => ({
                                    name: c.name,
                                    bounds: c.bounds,
                                    outline: c.outline || null
                                })).filter(c => c.outline || c.bounds);
                            }
                            if (data.countries) {
                                calibrations.countries = data.countries.map(c => ({
                                    name: c.name,
                                    bounds: c.bounds,
                                    outline: c.outline || null
                                })).filter(c => c.outline || c.bounds);
                            }
                            if (data.cities) {
                                calibrations.cities = data.cities.map(c => ({
                                    name: c.name,
                                    position: c.position
                                }));
                            }
                            updateItemList();
                            updateOutput();
                            renderOverlay();
                            alert('Loaded game data successfully!');
                        } catch (e) {
                            alert('Error parsing game data: ' + e.message);
                        }
                    }
                })
                .catch(e => alert('Error loading game.js: ' + e.message));
        }

        function copyOutput() {
            output.select();
            document.execCommand('copy');
        }

        function clearAll() {
            if (confirm('Clear all calibrations?')) {
                calibrations.continents = [];
                calibrations.countries = [];
                calibrations.cities = [];
                currentPolygonPoints = [];
                document.getElementById('pointCount').textContent = '0';
                renderOverlay();
                updateItemList();
                updateOutput();
            }
        }

        function exportAll() {
            const data = JSON.stringify(calibrations, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'map-calibrations.json';
            a.click();
        }

        updateItemList();
    </script>
</body>
</html>
